# myDouYingAdmin
这是我的视频后台管理系统，使用SSM开发。

/**
 * Bgm自动下载：
 * 1.Springboot开放接口，ssm调用让其下载（耦合度高）
 * 2.使用MQ消息队列，生产者（SSM）调用消费者（SpringBoot）
 * 3.使用Zookeeper，Springboot监听并且下载。集群(本项目使用该解决方法~。)
 *
 * Zookeeper:
 * 集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。
 * 中间件，提供协调服务。
 * 作用于分布式服务，可为大数据服务。
 *
 * Apache curator:Zookeeper客户端
 * 创建重试策略 -retryPolicy
 * 创建客户端 -client
 * 初始化客户端
 *
 */
 
 
补充：  
1.Zookeeper命名服务 
  在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。 
  
2.Zookeeper的配置管理 
  程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。 
  
3.Zookeeper集群管理 
  集群管理在乎两点：是否有机器退出和加入、选举master。  
  对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。 
  新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。 
   
4.Zookeeper分布式锁 
  有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。  
  对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。  
  对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。
   
5.Zookeeper队列管理 
两种类型的队列： 
  1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。  
  2、队列按照 FIFO 方式进行入队和出队操作。  
  第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。  
  第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。 
   
6.分布式与数据复制  
  Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：  
   1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；  
   2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；  
   3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。  
  从客户端读写访问的透明度来看，数据复制集群系统分下面两种：  
   1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离； 
   2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。
   对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立   observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。
  
  

